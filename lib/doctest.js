// Generated by CoffeeScript 1.4.0

/*
          >>>
          >>>                        >>>                         >>>
     >>>>>>>>   >>>>>>>    >>>>>>>   >>>>>   >>>>>>>    >>>>>>   >>>>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>   >>>  >>>       >>>
    >>>   >>>  >>>   >>>  >>>        >>>    >>>>>>>>>  >>>>>>>>  >>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>             >>>  >>>
     >>>>>>>>   >>>>>>>    >>>>>>>    >>>>   >>>>>>>    >>>>>>    >>>>
    .....................x.......xx.x.................................
*/


(function() {
  var CoffeeScript, doctest, escodegen, esprima, fetch, q, rewrite, _,
    __slice = [].slice;

  doctest = function() {
    var urls;
    urls = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return _.each(urls, fetch);
  };

  if (typeof window !== 'undefined') {
    _ = window._, CoffeeScript = window.CoffeeScript, escodegen = window.escodegen, esprima = window.esprima;
    window.doctest = doctest;
  } else {
    _ = require('underscore');
    CoffeeScript = require('coffee-script');
    escodegen = require('escodegen');
    esprima = require('esprima');
    module.exports = doctest;
  }

  doctest.version = '0.4.1';

  doctest.queue = [];

  doctest.input = function(fn) {
    return this.queue.push(fn);
  };

  doctest.output = function(num, fn) {
    fn.line = num;
    return this.queue.push(fn);
  };

  doctest.run = function() {
    var actual, expected, fn, input, num, results;
    results = [];
    input = null;
    while (fn = this.queue.shift()) {
      if (!(num = fn.line)) {
        if (typeof input === "function") {
          input();
        }
        input = fn;
        continue;
      }
      actual = (function() {
        try {
          return input();
        } catch (error) {
          return error.constructor;
        }
      })();
      expected = fn();
      results.push([_.isEqual(actual, expected), q(expected), q(actual), num]);
      input = null;
    }
    return this.complete(results);
  };

  doctest.complete = function(results) {
    var actual, expected, num, pass, r, _i, _len, _ref, _ref1, _results;
    console.log(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        pass = results[_i][0];
        _results.push(pass ? '.' : 'x');
      }
      return _results;
    })()).join(''));
    _ref = (function() {
      var _j, _len, _results1;
      _results1 = [];
      for (_j = 0, _len = results.length; _j < _len; _j++) {
        r = results[_j];
        if (!r[0]) {
          _results1.push(r);
        }
      }
      return _results1;
    })();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], pass = _ref1[0], expected = _ref1[1], actual = _ref1[2], num = _ref1[3];
      _results.push(console.warn("expected " + expected + " on line " + num + " (got " + actual + ")"));
    }
    return _results;
  };

  fetch = function(path) {
    var fs, script;
    console.log("retrieving " + path + "...");
    if (typeof window !== 'undefined') {
      if (path[0] === '.' && (script = jQuery('script[src$="doctest.js"]')).length) {
        path = script.attr('src').replace(/doctest[.]js$/, path);
      }
      return jQuery.ajax(path, {
        dataType: 'text',
        success: function(text) {
          var name, source, type, _ref;
          _ref = /[^/]+[.](coffee|js)$/.exec(path), name = _ref[0], type = _ref[1];
          console.log("running doctests in " + name + "...");
          source = rewrite(text, type);
          if (type === 'coffee') {
            source = CoffeeScript.compile(source);
          }
          Function(source)();
          return doctest.run();
        }
      });
    } else {
      fs = require('fs');
      return fs.readFile(path, 'utf8', function(err, text) {
        var file, name, source, type, _ref;
        _ref = /[^/]+[.](coffee|js)$/.exec(path), name = _ref[0], type = _ref[1];
        console.log("running doctests in " + name + "...");
        source = rewrite(text, type);
        if (type === 'coffee') {
          source = CoffeeScript.compile(source);
        }
        name += "-" + (+(new Date));
        file = "" + __dirname + "/" + name + ".js";
        fs.writeFileSync(file, source, 'utf8');
        require("./" + name);
        fs.unlink(file);
        return doctest.run();
      });
    }
  };

  rewrite = function(input, type) {
    var comment, end, f, idx, line, lines, loc, processComment, start, _i, _len, _ref, _ref1;
    input = input.replace(/\r\n?/g, '\n');
    f = function(indent, expr) {
      switch (type) {
        case 'coffee':
          return "->\n" + indent + "  " + expr + "\n" + indent;
        case 'js':
          return "function() {\n" + indent + "  return " + expr + "\n" + indent + "}";
      }
    };
    processComment = (function(expr) {
      return function(_arg, start) {
        var comment, indent, line, lines, match, value, _i, _len, _ref, _ref1;
        value = _arg.value;
        lines = [];
        _ref = value.split('\n');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _ref1 = /^([ \t]*)(.*)/.exec(line), match = _ref1[0], indent = _ref1[1], comment = _ref1[2];
          if (match = /^>(.*)/.exec(comment)) {
            if (expr) {
              lines.push("" + indent + "__doctest.input(" + (f(indent, expr)) + ");");
            }
            expr = match[1];
          } else if (match = /^[.]+(.*)/.exec(comment)) {
            expr += "\n" + indent + "  " + match[1];
          } else if (expr) {
            lines.push("" + indent + "__doctest.input(" + (f(indent, expr)) + ");");
            lines.push("" + indent + "__doctest.output(" + start.line + ", " + (f(indent, line)) + ");");
            expr = '';
          }
        }
        return escodegen.generate(esprima.parse(lines.join('\n')), {
          indent: '  '
        });
      };
    })('');
    _ref = esprima.parse(input, {
      comment: true,
      loc: true
    }).comments;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      loc = _ref[_i].loc;
      comment = esprima.parse(input, {
        comment: true,
        loc: true
      }).comments[0];
      _ref1 = comment.loc, start = _ref1.start, end = _ref1.end;
      lines = [null].concat(__slice.call(input.split('\n')));
      idx = start.line;
      line = lines[idx];
      if (end.line === start.line) {
        lines[idx] = line.substr(0, start.column) + line.substr(end.column);
      } else {
        lines[idx] = line.substr(0, start.column);
        while (idx += 1) {
          if (idx === end.line) {
            lines[idx] = lines[idx].substr(end.column);
            break;
          }
          lines[idx] = '';
        }
      }
      line = lines[start.line];
      lines[start.line] = line.substr(0, start.column) + processComment(comment, loc.start) + line.substr(start.column);
      input = lines.slice(1).join('\n');
    }
    if (typeof window !== 'undefined') {
      return "window.__doctest = doctest;\n" + input;
    } else if (type === 'coffee') {
      return "__doctest = require '../lib/doctest'\n" + input;
    } else if (type === 'js') {
      return "var __doctest = require('../lib/doctest');\n" + input;
    }
  };

  q = function(object) {
    switch (typeof object) {
      case 'string':
        return "\"" + object + "\"";
      case 'function':
        try {
          throw object();
        } catch (error) {
          if (error instanceof Error) {
            return object.name;
          }
        }
    }
    return object;
  };

}).call(this);
