// Generated by CoffeeScript 1.6.3
/*
          >>>
          >>>                        >>>                         >>>
     >>>>>>>>   >>>>>>>    >>>>>>>   >>>>>   >>>>>>>    >>>>>>   >>>>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>   >>>  >>>       >>>
    >>>   >>>  >>>   >>>  >>>        >>>    >>>>>>>>>  >>>>>>>>  >>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>             >>>  >>>
     >>>>>>>>   >>>>>>>    >>>>>>>    >>>>   >>>>>>>    >>>>>>    >>>>
    .....................x.......xx.x.................................
*/


(function() {
  var CoffeeScript, defineFunctionString, doctest, escodegen, esprima, fetch, isModule, log, noop, repr, rewrite, run, _;

  doctest = function(path, callback) {
    if (callback == null) {
      callback = noop;
    }
    return fetch(path, function(text, type) {
      var evaluate, queue, results, source;
      source = rewrite[type](text);
      if (isModule(source)) {
        source += ";\n" + defineFunctionString;
      }
      evaluate = Function('__doctest', source);
      queue = [];
      evaluate({
        input: function(fn) {
          return queue.push([fn]);
        },
        output: function(num, fn) {
          return queue.push([fn, num]);
        }
      });
      results = run(queue);
      log(results);
      return callback(results);
    });
  };

  doctest.version = '0.4.1';

  if (typeof window !== 'undefined') {
    _ = window._, CoffeeScript = window.CoffeeScript, escodegen = window.escodegen, esprima = window.esprima;
    window.doctest = doctest;
  } else {
    _ = require('underscore');
    CoffeeScript = require('coffee-script');
    escodegen = require('escodegen');
    esprima = require('esprima');
    module.exports = doctest;
  }

  fetch = function(path, callback) {
    var fs, script;
    console.log("retrieving " + path + "...");
    if (typeof window !== 'undefined') {
      if (path[0] === '.' && (script = jQuery('script[src$="doctest.js"]')).length) {
        path = script.attr('src').replace(/doctest[.]js$/, path);
      }
      return jQuery.ajax(path, {
        dataType: 'text',
        success: function(text) {
          var name, type, _ref;
          _ref = /[^/]+[.](coffee|js)$/.exec(path), name = _ref[0], type = _ref[1];
          console.log("running doctests in " + name + "...");
          return callback(text, type);
        }
      });
    } else {
      fs = require('fs');
      return fs.readFile(path, 'utf8', function(err, text) {
        var name, type, _ref;
        _ref = /[^/]+[.](coffee|js)$/.exec(path), name = _ref[0], type = _ref[1];
        console.log("running doctests in " + name + "...");
        return callback(text, type);
      });
    }
  };

  rewrite = function(input, type) {
    return rewrite[type](input.replace(/\r\n?/g, '\n'));
  };

  rewrite.js = function(input) {
    var comment, end, f, idx, line, lines, loc, processComment, start, _i, _len, _ref, _ref1;
    f = function(expr) {
      return "function() {\n  return " + expr + "\n}";
    };
    processComment = (function(expr) {
      return function(_arg, start) {
        var comment, indent, line, lines, match, value, _i, _len, _ref, _ref1;
        value = _arg.value;
        lines = [];
        _ref = value.split('\n');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _ref1 = /^([ \t]*)(.*)/.exec(line), match = _ref1[0], indent = _ref1[1], comment = _ref1[2];
          if (match = /^>(.*)/.exec(comment)) {
            if (expr) {
              lines.push("__doctest.input(" + (f(expr)) + ")");
            }
            expr = match[1];
          } else if (match = /^[.]+(.*)/.exec(comment)) {
            expr += "\n" + match[1];
          } else if (expr) {
            lines.push("__doctest.input(" + (f(expr)) + ")");
            lines.push("__doctest.output(" + start.line + ", " + (f(line)) + ")");
            expr = '';
          }
        }
        return escodegen.generate(esprima.parse(lines.join('\n')), {
          indent: '  '
        });
      };
    })('');
    _ref = esprima.parse(input, {
      comment: true,
      loc: true
    }).comments;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      loc = _ref[_i].loc;
      comment = esprima.parse(input, {
        comment: true,
        loc: true
      }).comments[0];
      _ref1 = comment.loc, start = _ref1.start, end = _ref1.end;
      lines = input.split('\n');
      idx = start.line - 1;
      line = lines[idx];
      if (end.line === start.line) {
        lines[idx] = line.substr(0, start.column) + line.substr(end.column);
      } else {
        lines[idx] = line.substr(0, start.column);
        while (++idx !== end.line - 1) {
          lines[idx] = '';
        }
        lines[idx] = lines[idx].substr(end.column);
      }
      line = lines[start.line - 1];
      lines[start.line - 1] = line.substr(0, start.column) + processComment(comment, loc.start) + line.substr(start.column);
      input = lines.join('\n');
    }
    return input;
  };

  rewrite.coffee = function(input) {
    var comment, expr, f, idx, indent, line, lines, match, _i, _len, _ref, _ref1;
    f = function(indent, expr) {
      return "->\n" + indent + "  " + expr + "\n" + indent;
    };
    lines = [];
    expr = '';
    _ref = input.split('\n');
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      line = _ref[idx];
      if (match = /^([ \t]*)#[ \t]*(.+)/.exec(line)) {
        _ref1 = match, match = _ref1[0], indent = _ref1[1], comment = _ref1[2];
        if (match = /^>(.*)/.exec(comment)) {
          if (expr) {
            lines.push("" + indent + "__doctest.input " + (f(indent, expr)));
          }
          expr = match[1];
        } else if (match = /^[.]+(.*)/.exec(comment)) {
          expr += "\n" + indent + "  " + match[1];
        } else if (expr) {
          lines.push("" + indent + "__doctest.input " + (f(indent, expr)));
          lines.push("" + indent + "__doctest.output " + (idx + 1) + ", " + (f(indent, comment)));
          expr = '';
        }
      } else {
        lines.push(line);
      }
    }
    return CoffeeScript.compile(lines.join('\n'));
  };

  defineFunctionString = 'function define() {\n  var arg, idx;\n  for (idx = 0; idx < arguments.length; idx += 1) {\n    arg = arguments[idx];\n    if (typeof arg === \'function\') {\n      arg();\n      break;\n    }\n  }\n}';

  isModule = function(source) {
    return _.some(esprima.parse(source).body, function(node) {
      return node.type === 'ExpressionStatement' && node.expression.type === 'CallExpression' && node.expression.callee.type === 'Identifier' && node.expression.callee.name === 'define';
    });
  };

  run = function(queue) {
    var actual, arr, error, expected, input, results, _i, _len;
    results = [];
    input = noop;
    for (_i = 0, _len = queue.length; _i < _len; _i++) {
      arr = queue[_i];
      switch (arr.length) {
        case 1:
          input();
          input = arr[0];
          break;
        case 2:
          actual = (function() {
            try {
              return input();
            } catch (_error) {
              error = _error;
              return error.constructor;
            }
          })();
          expected = arr[0]();
          results.push([_.isEqual(actual, expected), repr(expected), repr(actual), arr[1]]);
          input = noop;
      }
    }
    return results;
  };

  log = function(results) {
    var actual, expected, num, pass, _i, _len, _ref;
    console.log(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        pass = results[_i][0];
        _results.push(pass ? '.' : 'x');
      }
      return _results;
    })()).join(''));
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      _ref = results[_i], pass = _ref[0], expected = _ref[1], actual = _ref[2], num = _ref[3];
      if (!pass) {
        console.warn("expected " + expected + " on line " + num + " (got " + actual + ")");
      }
    }
  };

  noop = function() {};

  repr = function(val) {
    switch (Object.prototype.toString.call(val)) {
      case '[object String]':
        return '"' + val.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
      case '[object Function]':
        return val.name;
      default:
        return val;
    }
  };

}).call(this);
